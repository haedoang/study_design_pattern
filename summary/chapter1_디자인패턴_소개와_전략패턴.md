## 디자인 패턴 소개와 전략 패턴

### 상속을 통한 기능 추가의 문제점 
- 상속의 사용은 모든 하위 클래스에 영향을 미친다
  - ex) `fly()` 메서드를 사용하지 않을 하위 클래스는 메서드를 오버라이드 해야 한다
- 하위 클래스의 코드가 중복된다

### 인터페이스를 통한 기능 추가의 문제점
- 모든 구현체에서 인터페이스를 구현하는 문제가 발생한다
- 하위 클래스의 코드가 중복된다

--- 
### 디자인원칙1. 애플리케이션에서 달라지느 부분을 찾아내고, 달라지지 않는 부분과 분리한다
- 달라지는 부분을 찾아 나머지 코드에 영향을 주지 않도록 `캡슐화`한다
    ```text
    Duck 클래스 --->  나는 행동 
                    꽥꽥거리는 행동 
    ```

### 디자인원칙2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다
- `캡슐화`의 대상이 되는 행동을 인터페이스를 통해 행동을 구현한다
- 인터페이스에 맞추어 프로그래밍한다는 뜻은 `상위 형식`에 맞춰 프로그래밍 한다는 뜻이다
- 다형성 사용 예시)
    ```java
        Dog dog = new Dog();
        dog.bark();         //구현체에 맞춰 프로그래밍
    
        Animal dog = new Dog();
        animal.makeSound(); // 상위 형식에 맞춘 프로그래밍
    
        a = getAnimal();
        a.makeSound();      //구체적으로 구현된 객체를 대입 
    ```

- #### 인터페이스에 맞춘 프로그래밍은 코드의 재사용성과 변경에 유연하다
  - 상속과 인터페이스를 통한 문제점을 해결할 수 있다
  - 기능을 다른 클래스에 `위임`한다
```text
        <Interface>          
        FlyBehavior      <------------ Duck 클래스    
      ______|______                    FlyBehavior
      |           |                         |
FlyWithWings   FlyNoWay                     |
  fly() {       fly() {                MallardDuck
    ...           ...          FlyBehavior = new FlyWithWings(); 
  }             }
```

### 디자인원칙3. 상속보다는 구성을 사용한다
- `A에는 B가 있다`. 이를 `구성(Compositon)` 이라 한다
- 예시) `나는 행동`, `꽥꽥거리는 행동`을 Duck 클래스가 가지고 있다(Composition)
  - Duck 클래스는 행동 객체로 구성되어 행동을 부여받는다


### 전략 패턴
- 알고리즘군을 정의하고 캡슐화하여 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다
- 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다
- 객체의 행위를 동적으로 변경할 때 직접 행위를 수정하지 않고 `전략`을 변경하기만 하면 된다